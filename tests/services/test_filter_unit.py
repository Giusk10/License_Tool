"""
test: services/scanner/test_filter_unit.py

Test unitari per il modulo servizio filtro.
Questo modulo valida la logica per filtrare i risultati ScanCode, inclusi:
- Costruzione di rappresentazioni JSON minime.
- Rimozione dei file di licenza principale dall'analisi.
- Filtraggio basato su regex di corrispondenze invalide o irrilevanti.
- Gestione di voci di licenza duplicate.
- Logica per filtrare licenze contenute/sottoinsiemi.
"""

import pytest
import json
import os
import re
from unittest.mock import patch, mock_open

# Import functions to be tested
from app.services.scanner.filter import (
    filter_licenses,
    build_minimal_json,
    remove_main_license,
    regex_filter,
    check_license_spdx_duplicates,
    filter_contained_licenses
)

# --- FIXTURE ---

@pytest.fixture(autouse=True)
def setup_filter_test_env():
    """
    Configura l'ambiente per tutti i test.
    Patchea MINIMAL_JSON_BASE_DIR direttamente nel modulo scanner.filter
    e mocka os.makedirs per prevenire cambiamenti del file system.
    """
    # This patch only works if MINIMAL_JSON_BASE_DIR is imported correctly in filter.py
    with patch("app.services.scanner.filter.MINIMAL_JSON_BASE_DIR", "/mock/dir"), \
            patch("os.makedirs"):
        yield

@pytest.fixture
def mock_scancode_data():
    """
    Fixture che fornisce una struttura dati di esempio grezza da ScanCode.
    Contiene file legali e illegali con vari tipi di corrispondenza.
    """
    return {
        "files": [
            {
                "path": "file1.py",
                "is_legal": False,
                "is_key_file": False,
                "percentage_of_license_text": 90.5,
                "license_detections": [
                    {
                        "matches": [
                            {
                                "from_file": "file1.py",
                                "license_expression_spdx": "MIT",
                                "matched_text": "Permission is hereby granted..."
                            },
                            {
                                "from_file": "file1.py",
                                "license_expression_spdx": "LicenseRef-scancode-unknown",
                                "matched_text": "foobar"
                            }
                        ]
                    }
                ]
            },
            {
                "path": "README.md",
                "is_legal": False,
                "is_key_file": False,
                "percentage_of_license_text": 10.0,
                "license_detections": [
                    {
                        "matches": [
                            {
                                "from_file": "README.md",
                                "license_expression_spdx": "MIT",
                                "matched_text": "See the MIT license file for details."
                            }
                        ]
                    }
                ]
            }
        ]
    }

@pytest.fixture
def mock_rules_json():
    """
    Fixture che simula il contenuto di license_rules.json.
    Definisce pattern per testo ignorato, changelog, tag SPDX e link validi.
    """
    return {
        "ignore_patterns": [
            "(see\\s+(the\\s+)?license\\s+file)",
            "generated by"
        ],
        "changelog_patterns": [
            "migrated to"
        ],
        "spdx_tag_pattern": "SPDX-License-Identifier:\\s*([\\w\\.\\-\\+]+)",
        "valid_license_text_patterns": [
            "Permission is hereby granted",
            "Licensed under the Apache License"
        ],
        "valid_license_link_patterns": [
            "https?://opensource\\.org/licenses/"
        ],
        "min_matched_text_length": 10
    }

# --- TEST UNITARI: build_minimal_json ---

def test_build_minimal_json(mock_scancode_data):
    """
    Testa la creazione standard della struttura JSON minima.
    Verifica che i file siano correttamente analizzati e mappati allo schema minimo.
    """
    with patch("builtins.open", mock_open()) as mocked_file, \
            patch("os.makedirs") as mock_makedirs:
        result = build_minimal_json(mock_scancode_data)

        # Verify dummy path patched by fixture
        mock_makedirs.assert_called_with("/mock/dir", exist_ok=True)

        files = result["files"]
        assert len(files) == 2
        f1 = files[0]
        assert f1["path"] == "file1.py"
        assert len(f1["matches"]) == 1
        assert f1["matches"][0]["license_spdx"] == "MIT"

def test_build_minimal_json_edge_cases():
    """
    Testa casi limite per build_minimal_json:
    - 'path' mancante nella voce file.
    - Mancata corrispondenza tra 'path' e 'from_file'.
    Verifica che voci invalide siano escluse.
    """
    data = {
        "files": [
            {"path": None},
            {
                "path": "a.py",
                "is_legal": False, "is_key_file": False, "percentage_of_license_text": 0,
                "license_detections": [{
                    "matches": [{
                        "from_file": "other.py",
                        "license_expression_spdx": "MIT",
                        "matched_text": "text"
                    }]
                }]
            }
        ]
    }
    with patch("builtins.open", mock_open()), \
            patch("os.makedirs"):
        res = build_minimal_json(data)
        assert len(res["files"]) == 0

# --- TEST UNITARI: remove_main_license ---

def test_remove_main_license_single():
    """
    Testa la rimozione del file di licenza principale dalla lista.
    Verifica che se un file corrisponde al percorso/SPDX della licenza principale, sia filtrato.
    """
    data = {
        "files": [
            {"path": "LICENSE", "matches": [{"license_spdx": "MIT"}]},
            {"path": "app.py", "matches": [{"license_spdx": "Apache-2.0"}]}
        ]
    }
    result = remove_main_license("MIT", "LICENSE", data)
    assert len(result["files"]) == 1
    assert result["files"][0]["path"] == "app.py"

def test_remove_main_license_multiple_matches_value_error():
    """
    Testa il comportamento quando il file target ha più corrispondenze di licenza.
    Garantisce una gestione rigorosa dove file ambigui potrebbero essere rimossi o gestiti con grazia.
    """
    data = {
        "files": [
            {
                "path": "target.py",
                "matches": [
                    {"license_spdx": "MIT"},
                    {"license_spdx": "MIT"}
                ]
            }
        ]
    }
    result = remove_main_license("MIT", "target.py", data)
    assert len(result["files"]) == 0

# --- TEST UNITARI: filter_contained_licenses ---

def test_filter_contained_licenses_logic():
    """
    Testa la logica per filtrare licenze ridondanti contenute in altre espressioni di licenza.
    Esempio: 'MIT' dovrebbe essere rimosso se 'Apache-2.0 AND MIT' è presente.
    """
    items = [
        {"license_spdx": "MIT"},
        {"license_spdx": "Apache-2.0 AND MIT"}
    ]
    res = filter_contained_licenses(items)
    assert len(res) == 1
    assert res[0]["license_spdx"] == "Apache-2.0 AND MIT"

def test_filter_contained_licenses_dirty_inputs():
    """
    Testa la robustezza di filter_contained_licenses contro input sporchi
    come stringhe vuote o valori None.
    """
    items = [
        {"license_spdx": ""},
        {"license_spdx": None},
        {"license_spdx": "MIT"}
    ]
    res = filter_contained_licenses(items)
    assert len(res) == 3

# --- TEST UNITARI: regex_filter ---

def test_regex_filter_missing_rules_file():
    """
    Verifica che regex_filter sollevi FileNotFoundError se il file regole è mancante.
    """
    with patch("os.path.exists", return_value=False):
        with pytest.raises(FileNotFoundError):
            regex_filter({"files": []}, False)

def test_regex_filter_valid_tag_group_1(mock_rules_json):
    """
    Testa il filtraggio regex utilizzando il primo gruppo di cattura di un pattern.
    Verifica l'estrazione dell'ID SPDX da tag come 'SPDX-License-Identifier: MIT'.
    """
    data = {
        "files": [{
            "path": "file.c", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [{
                "license_spdx": "MIT",
                "matched_text": "SPDX-License-Identifier: MIT"
            }]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert result["files"][0]["matches"][0]["license_spdx"] == "MIT"

def test_regex_filter_spdx_tag_group_3(mock_rules_json):
    """
    Testa il filtraggio regex con pattern complessi che coinvolgono più gruppi.
    Verifica che il gruppo corretto (3° in questo caso) sia estratto.
    """
    custom_rules = mock_rules_json.copy()
    custom_rules["spdx_tag_pattern"] = "(Tag: (.+))|(Alt: (.+))"
    data = {
        "files": [{
            "path": "file.c", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [{
                "license_spdx": "MIT",
                "matched_text": "Alt: Apache-2.0"
            }]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(custom_rules))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert "Apache-2.0" in result["files"][0]["matches"][0]["license_spdx"]

def test_regex_filter_valid_link_fallback(mock_rules_json):
    """
    Testa il comportamento di fallback quando il testo di licenza è sconosciuto ma contiene un URL valido.
    Verifica che la voce sia mantenuta se l'URL corrisponde a pattern consentiti.
    """
    data = {
        "files": [{
            "path": "link.txt", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [{
                "license_spdx": "LicenseRef-scancode-unknown",
                "matched_text": "Check https://opensource.org/licenses/MIT"
            }]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert result["files"][0]["matches"][0]["license_spdx"] == "LicenseRef-scancode-unknown"

def test_regex_filter_scancode_id_checks(mock_rules_json):
    """
    Testa la gestione di ID interni specifici di ScanCode (ad es., LicenseRef-scancode-generic).
    Verifica che ID 'generic' siano trattati diversamente da licenze valide o ref sconosciuti.
    """
    data = {
        "files": [{
            "path": "checks.txt", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [
                {"license_spdx": "LicenseRef-scancode-generic",
                 "matched_text": "Valid Link: https://opensource.org/licenses/MIT"},
                {"license_spdx": "LicenseRef-unknown-license",
                 "matched_text": "Valid Link: https://opensource.org/licenses/MIT"},
                {"license_spdx": "Apache-2.0", "matched_text": "Valid Link: https://opensource.org/licenses/MIT"}
            ]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        matches = result["files"][0]["matches"]
        assert matches[0]["license_spdx"] == "LicenseRef-scancode-unknown"
        assert matches[1]["license_spdx"] == "LicenseRef-scancode-unknown"
        assert matches[2]["license_spdx"] == "Apache-2.0"

# --- TEST UNITARI: check_license_spdx_duplicates ---

def test_check_license_spdx_duplicates_dirty_data():
    """
    Testa il controllo duplicati con dati sporchi (None o stringhe vuote).
    Verifica che valori invalidi siano puliti mentre quelli validi rimangano.
    """
    data = {
        "files": [
            {
                "path": "test.py", "score": 100,
                "matches": [
                    {"license_spdx": None, "matched_text": "t1"},
                    {"license_spdx": "", "matched_text": "t2"},
                    {"license_spdx": "MIT", "matched_text": "t3"}
                ]
            }
        ]
    }
    result = check_license_spdx_duplicates(data)
    matches = result["files"][0]["matches"]
    assert len(matches) == 1
    assert matches[0]["license_spdx"] == "MIT"

def test_check_license_spdx_duplicates_deduplication():
    """
    Testa la logica di deduplicazione per ID SPDX identici.
    Verifica che duplicati case-insensitive siano uniti.
    """
    data = {
        "files": [{
            "path": "test.py", "score": 100,
            "matches": [
                {"license_spdx": "MIT", "matched_text": "t1"},
                {"license_spdx": "mit", "matched_text": "t2"}
            ]
        }]
    }
    result = check_license_spdx_duplicates(data)
    assert len(result["files"][0]["matches"]) == 1

# --- TEST DI INTEGRAZIONE ---

def test_filter_licenses_integration(mock_scancode_data, mock_rules_json):
    """
    Test di integrazione per la funzione principale filter_licenses.
    Verifica che l'intera pipeline (carica, filtra, rimuovi principale, pulisci) funzioni insieme.
    """
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = filter_licenses(mock_scancode_data, main_spdx="UNKNOWN", path="")
        assert len(result["files"]) == 1
        assert result["files"][0]["path"] == "file1.py"